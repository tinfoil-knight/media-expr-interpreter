<!DOCTYPE html>
<html>
  <head>
    <title>demo</title>
    <meta charset="utf-8" />
    <link href="site.css" rel="stylesheet" />
    <script src="lib.js"></script>
    <script src="ohm.js"></script>
    <script>
      const source = String.raw`
  // An Ohm grammar for arithmetic expressions.

  Arithmetic {
    Exp
      = AddExp

    AddExp
      = AddExp "+" MulExp  -- plus
      | AddExp "-" MulExp  -- minus
      | MulExp

    MulExp
      = MulExp "*" ExpExp  -- times
      | MulExp "/" ExpExp  -- divide
      | ExpExp

    ExpExp
      = PriExp "^" ExpExp  -- power
      | PriExp

    PriExp
      = "(" Exp ")"  -- paren
      | "+" PriExp   -- pos
      | "-" PriExp   -- neg
      | ident
      | number

    /*
      The following rules have *descriptions*, which are optional parenthesized "comments" following
      the name of a rule in its declaration. Rule descriptions are used to produce better error
      messages when the input is not recognized. E.g., if you try to match the input "123" with the
      'ident' rule below, Ohm will say that "an identifier" was expected. Without ident's rule
      description, the error message would have said that "a letter" was expected -- which is true,
      but probably too low-level to be helpful. Note that 'letter', 'alnum', and 'digit' are built-in
      rules with their own descriptions (you can see their declarations in src/built-in-rules.ohm).
    */
    ident  (an identifier)
      = letter alnum*

    number  (a number)
      = digit* "." digit+  -- fract
      | digit+             -- whole
  }
`;

      // We use `ohm.grammar` instantiate our Grammar from the source.
      const g = ohm.grammar(source);

      /*
  You can use a grammar's `match()` method to to recognize inputs. `match()` returns a
  `MatchResult`, which (among other things) can tell you if it succeeded or failed. E.g.,
*/

      g.match("1+2*3").succeeded(); // evaluates to `true`
      g.match("1+2*3").failed(); // evaluates to `false`

      const s = g.createSemantics();

      /*
  But a semantics without any operations or attributes is not very interesting: it doesn't do
  anything! Let's add an operation to our semantics that can be used to evaluate the arithmetic
  expressions:
*/

      const constants = { pi: Math.PI, e: Math.E };

      s.addOperation("interpret", {
        /*
        The arguments of a semantic action are the *concrete syntax tree (CST) nodes* produced by
        the body of its corresponding rule. E.g., here's the `Exp` rule from our arithmetic grammar:

          Exp
            = AddExp

        The body of this rule consists of an application of the `AddExp` rule, which produces a
        single CST node. Our semantic action for `Exp` will take this CST node as its only argument.

        (When you create a new operation / attribute, Ohm checks the arities of all of its semantic
        actions against their corresponding grammar rules -- this makes programming operations /
        attributes much less error-prone. More on this later.)

        Since the result of interpreting an `Exp` should be the same as the result of interpreting
        its enclosed "add expression", we write:
      */
        Exp(e) {
          return e.interpret(); // Note that operations are accessed as methods on the CST nodes.
        },

        /*
        Next, we look at `AddExp`:

          AddExp
            = AddExp "+" MulExp
            | AddExp "-" MulExp
            | MulExp

        The body of this rule is a disjunction (an "OR") of three parsing expressions. The first of
        these expressions,

          AddExp "+" MulExp

        will produce 3 CST nodes if it successfully matches the input: one for the `AddExp`
        application, one for the terminal "+", and another for the `MulExp` application. Likewise,
        the second choice,

          AddExp "-" MulExp

        will also produce 3 CST nodes on a successful match. The third choice, however,

          MulExp

        produces only 1 CST node. This mismatch would be problematic for someone who is trying to
        write a semantic action for `AddExp`: How many arguments should that semantic action take?
        Maybe it should depend on which choice succeeded? No, it turns out this wouldn't be such a
        good idea. For one thing, it would make the programmer's life more difficult (e.g., she
        would have to branch on the value of `arguments.length`). Worse, it would make it impossible
        for Ohm to check the arities of semantic actions at operation / attribute creation time,
        which would in turn make programming with Ohm error-prone.

        To avoid these problems, Ohm requires all of the operands in a disjunction

          e_1 | e_2 | ... | e_n

        to have the same *arity*, i.e., to produce the same number of CST nodes. In fact, the
        declaration of `AddExp`, as shown above, would result in a compile-time error -- namely,
        the call to `ohm.grammar()` would throw an exception.

        We can fix this by refactoring the first two choices of `AddExp` into their own rules:

          AddExp
            = AddExp_plus
            | AddExp_minus
            | MulExp

          AddExp_plus
            = AddExp "+" MulExp

          AddExp_minus
            = AddExp "-" MulExp

        Now `AddExp` has arity 1, and both `AddExp_plus` and `AddExp_minus` have arity 3, and
        everything is consistent.

        The downside of this refactoring is that it has made our grammar more verbose. Fortunately,
        Ohm provides a syntactic sugar for this common construction: it's called an *inline rule
        declaration*. When you write this (notice the *case labels* `plus` and `minus`, which look
        like comments in Haskell):

          AddExp
            = AddExp "+" MulExp  -- plus
            | AddExp "-" MulExp  -- minus
            | MulExp

        the expression to the left of each `--` becomes the body of a new rule whose name is the
        name of the original rule concatenated with an underscore and the case label:

          AddExp
            = AddExp_plus
            | AddExp_minus
            | MulExp

          AddExp_plus
            = AddExp "+" MulExp

          (Similarly for AddExp_minus)

        Now it's straightforward to write the semantic actions for `AddExp`, `AddExp_plus`, and
        `AddExp_minus`:
      */
        AddExp(e) {
          return e.interpret();
        },
        AddExp_plus(x, _, y) {
          return x.interpret() + y.interpret();
        },
        AddExp_minus(x, _, y) {
          return x.interpret() - y.interpret();
        },

        /*
        The following semantic actions are more of the same...
      */
        MulExp(e) {
          return e.interpret();
        },
        MulExp_times(x, _, y) {
          return x.interpret() * y.interpret();
        },
        MulExp_divide(x, _, y) {
          return x.interpret() / y.interpret();
        },
        ExpExp(e) {
          return e.interpret();
        },
        ExpExp_power(x, _, y) {
          return Math.pow(x.interpret(), y.interpret());
        },
        PriExp(e) {
          return e.interpret();
        },
        PriExp_paren(_l, e, _r) {
          return e.interpret();
        },
        PriExp_pos(_, e) {
          return e.interpret();
        },
        PriExp_neg(_, e) {
          return -e.interpret();
        },

        /*
        CST nodes have a couple of useful properties which contain information about where that
        node "came from" in the input:

        * `aNode.sourceString` contains the substring of the input that was consumed by the
          node.

        * `aNode.source.startIdx` and `aNode.source.endIdx` give the position of the source
          string in the original input.

        We use `this.sourceString` in the two rules below to interpret identifiers and numbers.
        (In a semantic action for a rule R, `this` is bound to the CST node that was produced by R.
        In other words, `this` is the parent of each of the CST nodes that are passed as arguments
        to the semantic action.)
      */
        ident(_l, _ns) {
          // Look up the value of a named constant, e.g., 'pi'.
          return constants[this.sourceString] || 0;
        },
        number(_) {
          // Use `parseFloat` to convert (e.g.) the string '123' to the number 123.
          return parseFloat(this.sourceString);
        },
      });

      /*
  So now that we've created a semantics for our arithmetic grammar and defined the `interpret`
  operation, how do we use them?
*/

      const r = g.match("(2+4)*7"); // First, you need a successful `MatchResult`.
      const n = s(r); // Then, you apply the semantics to that match result to get a CST node,
      console.log(n.interpret()); // ... on which you can access the functionality provided by the
      // semantics. (This will print `42`.)

      /*
  Now we'll add an `asLisp` attribute to our semantics that converts CST nodes to Lisp-like trees.
  Attributes are just like operations, but (i) they are accessed like properties -- not methods --
  on CST nodes, and (ii) their values are memoized.
*/

      s.addAttribute("asLisp", {
        AddExp_plus(x, _, y) {
          return ["+", x.asLisp, y.asLisp];
        },
        AddExp_minus(x, _, y) {
          return ["-", x.asLisp, y.asLisp];
        },
        MulExp_times(x, _, y) {
          return ["*", x.asLisp, y.asLisp];
        },
        MulExp_divide(x, _, y) {
          return ["/", x.asLisp, y.asLisp];
        },
        ExpExp_power(x, _, y) {
          return ["pow", x.asLisp, y.asLisp];
        },
        PriExp_paren(_l, e, _r) {
          return e.asLisp;
        },
        PriExp_pos(_, e) {
          return e.asLisp;
        },
        PriExp_neg(_, e) {
          return ["neg", e.asLisp];
        },
        ident(_l, _ns) {
          return this.sourceString;
        },
        number(_) {
          return this.sourceString;
        },

        /*
    When you create an operation or an attribute, you can optionally provide a `_nonterminal`
    semantic action that will be invoked when your action dictionary does not have a method that
    corresponds to the rule that created a CST node. The receiver (`this`) of the _nonterminal
    method will be that CST node, and its argument are the children of that node. Since the exact
    number of children can vary, we use the rest parameter syntax (`...children`) to capture all
    of the arguments as an array.
  */
        _nonterminal(...children) {
          if (children.length === 1) {
            // If this node has only one child, just return the Lisp-like tree of its child. This lets us
            // avoid writing semantic actions for the `Exp`, `AddExp`, `MulExp`, `ExpExp`, and `PriExp`
            // rules.
            return children[0].asLisp;
          } else {
            // If this node doesn't have exactly one child, we probably should have handled it specially.
            // So we'll throw an exception to let us know that we're missing a semantic action for this
            // type of node.
            throw new Error(
              "Uh-oh, missing semantic action for " + this.constructor
            );
          }
        },
      });

      /*
  Remember the CST node that we created from the expression '(2+4)*7'? Now it has an `asLisp`
  attribute:
*/

      n.asLisp; // evaluates to `["*", ["+", "2", "4"], "7"]`
      n.asLisp === n.asLisp; // evaluates to `true`

      // -------------------------------------------------------------------------------------------------

      const elt = makeElement;

      s.addOperation("toTree", {
        Exp(e) {
          return elt("exp", e.toTree());
        },
        AddExp(e) {
          return elt("addExp", e.toTree());
        },
        AddExp_plus(x, op, y) {
          return elt("plus", x.toTree(), op.toTree(), y.toTree());
        },
        AddExp_minus(x, op, y) {
          return elt("minus", x.toTree(), op.toTree(), y.toTree());
        },
        MulExp(e) {
          return elt("mulExp", e.toTree());
        },
        MulExp_times(x, op, y) {
          return elt("times", x.toTree(), op.toTree(), y.toTree());
        },
        MulExp_divide(x, op, y) {
          return elt("divide", x.toTree(), op.toTree(), y.toTree());
        },
        ExpExp(e) {
          return elt("expExp", e.toTree());
        },
        ExpExp_power(x, op, y) {
          return elt("power", x.toTree(), op.toTree(), y.toTree());
        },
        PriExp(e) {
          return elt("priExp", e.toTree());
        },
        PriExp_paren(op, e, cp) {
          return elt("paren", op.toTree(), e.toTree(), cp.toTree());
        },
        PriExp_pos(sign, e) {
          return elt("pos", sign.toTree(), e.toTree());
        },
        PriExp_neg(sign, e) {
          return elt("neg", sign.toTree(), e.toTree());
        },
        ident(_l, _ns) {
          return elt("ident", this.sourceString);
        },
        number(_) {
          return elt("number", this.sourceString);
        },

        // The _terminal semantic action specifies what your operation or attribute should do with
        // (you guessed it) terminals. Here, we return the terminal's `sourceString` attribute, which
        // is just the substring of the input that was consumed by that node.
        _terminal() {
          return this.sourceString;
        },
      });
    </script>
  </head>
  <body>
    <input
      type="text"
      id="input"
      placeholder="Enter an expression..."
      size="80"
    />
    <div id="errorDiv">
      <div id="spaces"></div>
      <wrapperWrapper
        ><wrapper>
          <div id="error">
            <label>Expected:</label><span id="errorDetails"></span>
          </div> </wrapper
      ></wrapperWrapper>
    </div>
    <div id="value"></div>
    <div id="lisp"></div>
    <div id="tree"></div>
    <script>
      /*
  This is the code that drives the UI in this demo.
*/

      const input = document.getElementById("input");
      const spaces = document.getElementById("spaces");
      const error = document.getElementById("error");
      const errorDiv = document.getElementById("errorDiv");
      const errorDetails = document.getElementById("errorDetails");

      input.value = "";
      hideError();

      function stringifyLisp(x) {
        return Array.isArray(x)
          ? "(" + x.map(stringifyLisp).join(" ") + ")"
          : x.toString();
      }

      input.oninput = function () {
        hideError();
        this.className = undefined;
        const r = g.match(this.value);
        if (r.succeeded()) {
          // Notice that you can do many different things with the same match result, i.e., you only have
          // to process the input once.
          show("value", s(r).interpret());
          show("lisp", stringifyLisp(s(r).asLisp));
          show("tree", s(r).toTree());
        } else if (this.value.trim().length === 0) {
          // The match failed because there was no input, so don't complain. (That would be annoying.)
          show("value", "");
          show("lisp", "");
          show("tree", "");
        } else {
          showError(r);
        }
      };

      function hideError() {
        input.className = undefined;
        errorDiv.className = errorDiv.className = "hidden";
      }

      function showError(r) {
        input.className = "error";
        setTimeout(function () {
          // Position the error bubble to line up with the offending input.
          spaces.innerHTML = repeat(" ", r.getRightmostFailurePosition());

          // Set up the details, i.e., what input was expected at that position.
          removeChildren(errorDetails);

          // Add the non-fluffy failures first...
          const nonFluffyFailures = r
            .getRightmostFailures()
            .filter((failure) => !failure.isFluffy());
          nonFluffyFailures.forEach(addErrorDetails);

          // ... then the fluffy ones
          const fluffyFailures = r
            .getRightmostFailures()
            .filter((failure) => failure.isFluffy());
          fluffyFailures.forEach(addErrorDetails);

          // Show the error balloon.
          errorDiv.className = "visible";
        }, 0);
      }

      function addErrorDetails(failure) {
        const element = createExpectedElement(failure);
        errorDetails.appendChild(element);
      }

      function createExpectedElement(failure) {
        if (failure.isStringTerminal()) {
          return elt(
            "literal",
            elt("light", '"'),
            elt("code", failure.getText()),
            elt("light", '"')
          );
        } else if (failure.isCode()) {
          return elt("code", failure.getText());
        } else {
          return elt("description", failure.getText());
        }
      }

      function setInput(text) {
        input.value = text;
        input.oninput();
      }

      // Show something interesting when the page loads.
      setInput("1 + 2 * 3 / 4^5");

      // -------------------------------------------------------------------------------------------------

      function assertEqual(expected, actual, message) {
        if (expected !== actual) {
          throw new Error(`${message}: expected ${expected}, got ${actual}`);
        }
      }

      window.test = () => {
        const $ = (sel) => document.querySelector(sel);

        setInput("33 * 5 + 100");
        assertEqual($("#value").textContent, "265", "value is correct");
        assertEqual(
          $("#lisp").textContent,
          "(+ (* 33 5) 100)",
          "LISP representation is correct"
        );
      };
    </script>
  </body>
</html>
